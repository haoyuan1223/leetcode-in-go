**题意概述**

一个人在迷宫中，要从起点$ S $走到终点$ T$。迷宫有两类特殊点，分别是：

- $M$：机关点，需要用石头触发
- $O$：石头点，一次可以搬一块石头

只有当所有 M 点均被触发以后，终点才可到达，问起点走到终点的最小代价。

**思路与算法**

虽然迷宫有很多格子，但是我们实际上的走法只有几种：

- 从 $ S $ 走到 $ O $，我们不会从 $S$ 直接走到 $M$，因为触发机关要先搬石头
- 从 $ O $ 走到 $ M $
- 从 $ M $ 走到 $ O $
- 从 $ M $ 走到 $ T $

有一点性质很重要，**不论我们触发机关还是搬运石头，都不会改变迷宫的连通状态。因此，两个点的最短距离一旦计算出，就不会再改变了**。 于是第一步，我们可以做一步预处理——我们计算所有特殊点（包括$ M，O，S，T$）互相之间的最短距离，即对这里面的每个点做一次 BFS。这样我们就不需要考虑其他点了。为什么要预处理出这些特殊点两两之间的距离，这个问题会在在下文中解释。

解决这个问题的关键是理解我们要以什么样的策略来取石头和触发机关：

- 在最开始，我们一定会从 $S$，经过某一个 $O$，到达某一个$ M$。那么对于特定的$ M $来说，我们枚举$ O $就可以计算$ S-O−M $的最短距离。那么如果我们要从起点 $S$ 到达 $M$，一定会选择这条距离最短的路。这样，我们首先得到了 $S$ 到每一个 $M$ 的最短距离。
  
- 假定我们已经从起点到达了某个 $M$ 了，接下来需要去其他的 $O$ 点搬石头接着触发其他的机关，这是一个 $M-O-M'$ 的路线。同样的道理，对于给定的 $M'$，中间的 $O$ 也是固定的。即给定 $M$ 和 $M'$ ，我们可以确定一个 $O$，使得 $M-O-M'$距离最短。我们同样可以记录下这个最短距离，即得到了 所有$ M $到 $M'$的最短距离。

- 最后，所有$ M$ 到 $T $的距离在前面已经计算出了。

我们需要所有的$ M $都被触发，$M $的触发顺序不同会导致行走的路径长度不同。假设这里一共有 $n$ 个$ M$，我们用$ d(i, j) $表示第$ i $个$ M $到第$ j$ 个 $M $经过某一个$ O$ 的最短距离。因为这里的 $n$不大于 16，我们可以使用一个 16 位的二进制数表示状态，这个二进制数的第$ i$ 位为 1 表示第$ i $个$ M$ 已经触发，为 0 表示第 $i $个$ M$ 还未被触发，记这个二进制数为$mask$。记 $Mi$为第$ i $个$ M$（下标从 1开始），每一个$mask $都可以表示成两个集合，一个已触发集合、一个未触发集合，例如$ n = 16，mask = 0000 1100 0001 0001$ 的已触发集合就可以表示为 $T = { M1, M5, M11, M12}$，剩下的元素都在未触发集合 $U - T$ 中。

我们定义$ f(mask,i) $表示当前在第 $ i $个$ M $处，触发状态为 $mask$ 的最小步数，如果当前$mask$ 代表的已触发集合为$ T$，未触发集合为$ U - T$，则我们可以推出这样的动态规划转移方程：

$$
f(mask,i) = min{f(mask|2^i,j) + d(j,i)}
$$

其中 $ mask|2^i $表示把 Mi 已触发的集合当中去掉，即 $mask$ 这个状态可以由 $mask|2^i$ 状态转移得到，转移时我们除了关注触发状态 $mask$ 的变化，我们还关注是从哪一个 $M$ 转移到了 $Mi$，我们可以枚举 $mask$ 当中已触发的所有的$ Mj(j != i) $作为上一个位置，而 $ d(j, i) $就是我们从 $j$ 转移到 $i$ 行走的最短步数，我们可以在预处理之后按照我们的策略得到所有的$ d(j, i) $（如果 $i$, $j$不可达可以设为正无穷），然后 $O(1)$ 查询，这就是预处理的目的。

实际上，在实现的时候，如果我们用记忆化搜索的方式实现，那么我们用到的是上面的转移方程；如果我们使用循环实现的话，也可以使用下面的转移方程，写法类似递推：

$$
f(mask|2^j, j) = min{f(mask, i) + d(i, j)}
$$
**题型小结**

这道题是一个非常经典的状态压缩动态规划模型：有$n $个任务$ {M1,M2...Mn} $，每两个任务之间有一个$ c(Mi, Mj) $表示在$ Mi$之后（下一个）做 $Mj$的花费，让你求解把$ n $个任务都做完需要的最小花费。通常这个 n会非常的小，因为需要构造$ 2^n$种状态，$c(Mi, Mj)$可能是题目给出，也可能是可以在很短的时间内计算出来的一个值。这类问题的状态设计一般都是$ f(mask,i)$ 表示当前任务完成的状态是$mask$，当前位置是$ i$，考虑转移的时候我们只需要考虑当前任务的上一个任务即可。

